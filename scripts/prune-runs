#!/bin/bash

# Script to prune completed Dagster run worker pods
# Keeps only the 5 newest completed pods in the dagster namespace

set -euo pipefail

# Configuration
NAMESPACE="dagster"
LABEL_SELECTOR="app.kubernetes.io/component=run_worker"
KEEP_COUNT=5
DRY_RUN=true

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Function to show usage
show_usage() {
    cat << EOF
Usage: $0 [OPTIONS]

Prune completed Dagster run worker pods, keeping only the newest 5.

OPTIONS:
    -f, --force     Actually delete pods (default is dry-run mode)
    -k, --keep N    Number of pods to keep (default: 5)
    -h, --help      Show this help message

EXAMPLES:
    $0                  # Dry run - show what would be deleted
    $0 --force          # Actually delete old pods
    $0 --keep 10        # Keep 10 newest pods instead of 5
    $0 --force --keep 3 # Delete all but 3 newest pods

EOF
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -f|--force)
            DRY_RUN=false
            shift
            ;;
        -k|--keep)
            KEEP_COUNT="$2"
            if ! [[ "$KEEP_COUNT" =~ ^[0-9]+$ ]] || [ "$KEEP_COUNT" -lt 1 ]; then
                print_error "Keep count must be a positive integer"
                exit 1
            fi
            shift 2
            ;;
        -h|--help)
            show_usage
            exit 0
            ;;
        *)
            print_error "Unknown option: $1"
            show_usage
            exit 1
            ;;
    esac
done

# Check if kubectl is available
if ! command -v kubectl &> /dev/null; then
    print_error "kubectl is not installed or not in PATH"
    exit 1
fi

# Check if we can access the cluster
if ! kubectl cluster-info &> /dev/null; then
    print_error "Cannot connect to Kubernetes cluster. Check your kubeconfig."
    exit 1
fi

# Check if namespace exists
if ! kubectl get namespace "$NAMESPACE" &> /dev/null; then
    print_error "Namespace '$NAMESPACE' does not exist"
    exit 1
fi

print_info "Pruning completed pods in namespace: $NAMESPACE"
print_info "Label selector: $LABEL_SELECTOR"
print_info "Keeping newest: $KEEP_COUNT pods"

if [ "$DRY_RUN" = true ]; then
    print_warning "DRY RUN MODE - No pods will be deleted. Use --force to actually delete."
fi

echo

# Get all pods with the specified label
print_info "Fetching pods with label $LABEL_SELECTOR..."

# Get pods sorted by creation timestamp (newest first) using kubectl's sorting
print_info "Getting pods sorted by creation time..."
PODS_SORTED=$(kubectl get pods -n "$NAMESPACE" -l "$LABEL_SELECTOR" \
    --field-selector=status.phase=Succeeded \
    --sort-by=.metadata.creationTimestamp \
    -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' 2>/dev/null || true)

if [ -z "$PODS_SORTED" ]; then
    print_info "No completed pods found with label $LABEL_SELECTOR"
    exit 0
fi

# Count total pods
TOTAL_PODS=$(echo "$PODS_SORTED" | wc -l | tr -d ' ')
print_info "Found $TOTAL_PODS completed pods"

if [ "$TOTAL_PODS" -le "$KEEP_COUNT" ]; then
    print_success "Only $TOTAL_PODS pods found, which is <= $KEEP_COUNT. Nothing to prune."
    exit 0
fi

print_info "Determining which pods to keep and delete..."

# Calculate how many pods to delete
DELETE_COUNT=$((TOTAL_PODS - KEEP_COUNT))

# Get pods to delete (oldest ones) - kubectl sorts oldest first, so we take the first DELETE_COUNT
PODS_TO_DELETE=$(echo "$PODS_SORTED" | head -n "$DELETE_COUNT")

# Get pods to keep (newest N) - take the last N pods
PODS_TO_KEEP=$(echo "$PODS_SORTED" | tail -n "$KEEP_COUNT")

echo
print_info "Pods to keep ($KEEP_COUNT newest):"
while IFS= read -r pod; do
    if [ -n "$pod" ]; then
        echo -e "  ${GREEN}✓${NC} $pod"
    fi
done <<< "$PODS_TO_KEEP"

echo
if [ "$DELETE_COUNT" -gt 0 ]; then
    print_warning "Pods to delete ($DELETE_COUNT older):"
    while IFS= read -r pod; do
        if [ -n "$pod" ]; then
            echo -e "  ${RED}✗${NC} $pod"
        fi
    done <<< "$PODS_TO_DELETE"

    echo
    if [ "$DRY_RUN" = true ]; then
        print_warning "DRY RUN: Would delete $DELETE_COUNT pods. Use --force to actually delete them."
    else
        print_info "Deleting $DELETE_COUNT pods..."

        # Delete pods one by one with error handling
        DELETED_COUNT=0
        FAILED_COUNT=0

        # Use a different approach to avoid subshell issues
        while IFS= read -r pod; do
            if [ -n "$pod" ]; then
                if kubectl delete pod "$pod" -n "$NAMESPACE" --ignore-not-found=true; then
                    print_success "Deleted: $pod"
                    DELETED_COUNT=$((DELETED_COUNT + 1))
                else
                    print_error "Failed to delete: $pod"
                    FAILED_COUNT=$((FAILED_COUNT + 1))
                fi
            fi
        done <<< "$PODS_TO_DELETE"

        echo
        if [ "$FAILED_COUNT" -eq 0 ]; then
            print_success "Successfully deleted all $DELETE_COUNT pods"
        else
            print_warning "Deleted $DELETED_COUNT pods, failed to delete $FAILED_COUNT pods"
        fi
    fi
else
    print_info "No pods to delete"
fi

echo
print_success "Pod pruning completed"
